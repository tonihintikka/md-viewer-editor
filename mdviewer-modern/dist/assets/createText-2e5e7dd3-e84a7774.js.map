{"version":3,"file":"createText-2e5e7dd3-e84a7774.js","sources":["../../node_modules/mermaid/dist/createText-2e5e7dd3.js"],"sourcesContent":["import { l as log, M as decodeEntities } from \"./mermaid-b5860b54.js\";\nimport { fromMarkdown } from \"mdast-util-from-markdown\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown) {\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  return withoutExtraSpaces;\n}\nfunction markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const { children } = fromMarkdown(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.value.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"emphasis\") {\n      node.children.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n  children.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.children.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n  return lines;\n}\nfunction markdownToHTML(markdown) {\n  const { children } = fromMarkdown(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      return node.value.replace(/\\n/g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.children.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"emphasis\") {\n      return `<em>${node.children.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.children.map(output).join(\"\")}</p>`;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  return children.map(output).join(\"\");\n}\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(\"\"), type },\n      { content: \"\", type }\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(\"\"), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(\"\"), type },\n    { content: remainingChars.join(\"\"), type }\n  ];\n}\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({ content }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? { content: \" \", type: \"normal\" };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({ content: joiner, type: \"normal\" });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(\n    `\n    <span class=\"${labelClass} ${classes}\" ` + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"max-width\", width + \"px\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  fo.style(\"width\", bbox.width);\n  fo.style(\"height\", bbox.height);\n  return fo.node();\n}\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  var _a;\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: \"normal\" }]);\n  const textDimension = (_a = testSpan.node()) == null ? void 0 : _a.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = (line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width;\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", -padding).attr(\"y\", -padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"emphasis\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\nconst createText = (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}) => {\n  log.info(\"createText\", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text);\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        // cspell: disable-line\n        (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n      ),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\nexport {\n  createText as a,\n  computeDimensionOfText as c\n};\n"],"names":["markdownToLines","markdown","preprocessedMarkdown","withoutMultipleNewlines","replace","dedent","preprocessMarkdown","children","fromMarkdown","lines","currentLine","processNode","node","parentType","type","value","split","forEach","textLine","index","push","word","content","contentNode","treeNode","splitWordToFitWidth","checkFit","text","splitWordToFitWidthRecursion","Intl","Segmenter","segment","map","s","usedChars","remainingChars","length","join","nextChar","rest","newWord","shift","splitLineToFitWidth","line","some","includes","Error","splitLineToFitWidthRecursion","words","newLine","joiner","nextWord","lineWithNextWord","unshift","createTspan","textElement","lineIndex","lineHeight","append","attr","computeWidthOfText","parentNode","testElement","testSpan","updateTextContentAndStyles","textLength","getComputedTextLength","remove","computeDimensionOfText","_a","textDimension","getBoundingClientRect","tspan","wrappedLine","innerTspan","createText","el","style","isTitle","classes","useHtmlLabels","isNode","width","addSvgBackground","log$1","info","htmlText","output","markdownToHTML","vertexNode","element","addBackground","fo","div","label","labelClass","dom","styleFn","html","labelStyle","bbox","height","addHtmlSpan","decodeEntities","svgLabel","g","structuredText","labelGroup","bkg","insert","checkWidth","line2","linesUnderWidth","preparedLine","getBBox","padding","createFormattedText"],"mappings":"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","x_google_ignoreList":[0]}